import * as fs from 'node:fs';
import * as path from 'node:path';
import { EventEmitter } from 'node:events';

import { parseEipc, formatParseError, type ParseError } from './language/parser.js';
import type { Module } from './language/generated/ast.js';
import { buildWiring } from './wire.js';

interface WiringOptions {
  /**
   * Absolute path to a folder containing valid ".eipc" schema files, every file
   * in this folder will be parsed and will be used to generate the wiring folder
   */
  schemaFolder: string;
  /**
   * Absolute path to a folder (does not have to already exist), if it exists it will
   * be completely wiped.  This method will fail if we detect a file in this folder
   * that was not created by this tool.
   */
  wiringFolder: string;
}

const IPC_SCHEMA_EXTENSION = '.eipc';
const MARKER_FILE = '.eipc-generated';

export async function generateWiring(opts: WiringOptions) {
  const schemaFiles = (await fs.promises.readdir(opts.schemaFolder)).filter((schemaFile) => path.extname(schemaFile) === IPC_SCHEMA_EXTENSION);

  // Read and parse all schema files
  const modules: Module[] = [];

  for (const schemaFile of schemaFiles) {
    const fullPath = path.resolve(opts.schemaFolder, schemaFile);
    const contents = await fs.promises.readFile(fullPath, 'utf8');

    const result = await parseEipc(contents, schemaFile);

    if (result.errors.length > 0) {
      const firstError = result.errors[0];
      throw new Error(formatParseError(firstError, schemaFile, contents));
    }

    modules.push(result.ast);
  }

  // Merge schema files in the same module namespace
  const mergedModules: Map<string, Module> = new Map();
  for (const module of modules) {
    if (mergedModules.has(module.name)) {
      mergedModules.get(module.name)!.elements.push(...module.elements);
    } else {
      mergedModules.set(module.name, module);
    }
  }

  // Validate existing wiringFolder before wiping
  if (fs.existsSync(opts.wiringFolder)) {
    const markerPath = path.resolve(opts.wiringFolder, MARKER_FILE);
    if (!fs.existsSync(markerPath)) {
      throw new Error(
        `Refusing to overwrite "${opts.wiringFolder}" - it exists but was not created by EIPC.\n\n` +
          `This safety check prevents accidentally deleting your files.\n\n` +
          `If this folder should be used for EIPC output, either:\n` +
          `  1. Delete it manually and re-run generation\n` +
          `  2. Choose a different output directory`,
      );
    }
    await fs.promises.rm(opts.wiringFolder, {
      recursive: true,
    });
  }

  await fs.promises.mkdir(opts.wiringFolder, {
    recursive: true,
  });

  // Write marker file to identify this as EIPC-generated
  await fs.promises.writeFile(
    path.resolve(opts.wiringFolder, MARKER_FILE),
    `This directory was generated by EIPC. Do not edit files here manually.\nGenerated at: ${new Date().toISOString()}\n`,
  );

  for (const parent of [opts.wiringFolder, path.resolve(opts.wiringFolder, '_internal')]) {
    for (const dir of ['browser', 'preload', 'renderer', 'renderer-hooks', 'common', 'common-runtime']) {
      await fs.promises.mkdir(path.resolve(parent, dir), {
        recursive: true,
      });
    }
  }

  const flatModules = [...mergedModules.values()];

  for (const module of flatModules) {
    const wiring = buildWiring(module);

    await fs.promises.writeFile(path.resolve(opts.wiringFolder, 'browser', `${module.name}.ts`), disableEslint(wiring.browser.external));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, 'preload', `${module.name}.ts`), disableEslint(wiring.preload.external));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, 'renderer', `${module.name}.ts`), disableEslint(wiring.renderer.external));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, 'renderer-hooks', `${module.name}.ts`), disableEslint(wiring.rendererHooks.external));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, 'common', `${module.name}.ts`), disableEslint(wiring.common.external));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, 'common-runtime', `${module.name}.ts`), disableEslint(wiring.commonRuntime.external));

    await fs.promises.writeFile(path.resolve(opts.wiringFolder, '_internal', 'browser', `${module.name}.ts`), disableEslint(wiring.browser.internal));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, '_internal', 'preload', `${module.name}.ts`), disableEslint(wiring.preload.internal));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, '_internal', 'renderer', `${module.name}.ts`), disableEslint(wiring.renderer.internal));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, '_internal', 'renderer-hooks', `${module.name}.ts`), disableEslint(wiring.rendererHooks.internal));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, '_internal', 'common', `${module.name}.ts`), disableEslint(wiring.common.internal));
    await fs.promises.writeFile(path.resolve(opts.wiringFolder, '_internal', 'common-runtime', `${module.name}.ts`), disableEslint(wiring.commonRuntime.internal));
  }
}

function disableEslint(content: string): string {
  return `/* eslint-disable */

${content}`;
}

export interface WiringWatcherEvents {
  'change-detected': [file: string];
  'file-added': [file: string];
  'file-removed': [file: string];
  'generation-start': [];
  'generation-complete': [];
  'generation-error': [error: Error];
  error: [error: Error];
}

class WiringWatcher extends EventEmitter<WiringWatcherEvents> {
  #closed = false;
  #debounceTimer: ReturnType<typeof setTimeout> | null = null;
  #fsWatcher: fs.FSWatcher | null = null;

  get closed(): boolean {
    return this.#closed;
  }

  setFsWatcher(watcher: fs.FSWatcher): void {
    this.#fsWatcher = watcher;
  }

  setDebounceTimer(timer: ReturnType<typeof setTimeout> | null): void {
    this.#debounceTimer = timer;
  }

  clearDebounceTimer(): void {
    if (this.#debounceTimer) {
      clearTimeout(this.#debounceTimer);
      this.#debounceTimer = null;
    }
  }

  close(): void {
    this.#closed = true;
    this.clearDebounceTimer();
    if (this.#fsWatcher) {
      this.#fsWatcher.close();
      this.#fsWatcher = null;
    }
  }
}

/**
 * Watch schema files for changes and regenerate wiring automatically.
 * Returns a promise that resolves with a watcher once ready.
 */
export async function watchWiring(opts: WiringOptions): Promise<WiringWatcher> {
  const watcher = new WiringWatcher();
  const knownFiles = new Set<string>();

  const generate = async () => {
    if (watcher.closed) return;

    watcher.emit('generation-start');
    try {
      await generateWiring(opts);
      watcher.emit('generation-complete');
    } catch (err) {
      watcher.emit('generation-error', err as Error);
    }
  };

  const scheduleGenerate = (file: string, eventType: 'change-detected' | 'file-added' | 'file-removed') => {
    watcher.emit(eventType, file);

    // Debounce rapid changes
    watcher.clearDebounceTimer();
    watcher.setDebounceTimer(
      setTimeout(() => {
        watcher.setDebounceTimer(null);
        generate();
      }, 100),
    );
  };

  const scanForFiles = async (): Promise<string[]> => {
    try {
      const files = await fs.promises.readdir(opts.schemaFolder);
      return files.filter((f) => path.extname(f) === IPC_SCHEMA_EXTENSION);
    } catch {
      return [];
    }
  };

  // Ensure schema folder exists
  if (!fs.existsSync(opts.schemaFolder)) {
    await fs.promises.mkdir(opts.schemaFolder, { recursive: true });
  }

  // Initial scan
  const initialFiles = await scanForFiles();
  for (const file of initialFiles) {
    knownFiles.add(file);
  }

  // Initial generation - throw on error so the promise rejects
  await generateWiring(opts);

  // Watch the directory
  const fsWatcher = fs.watch(opts.schemaFolder, { persistent: true }, async (eventType, filename) => {
    if (watcher.closed) return;
    if (!filename) return;

    if (path.extname(filename) === IPC_SCHEMA_EXTENSION) {
      const fullPath = path.join(opts.schemaFolder, filename);
      const exists = fs.existsSync(fullPath);

      if (eventType === 'rename') {
        if (exists && !knownFiles.has(filename)) {
          // New file added
          knownFiles.add(filename);
          scheduleGenerate(filename, 'file-added');
        } else if (exists && knownFiles.has(filename)) {
          // File was replaced (common on macOS when editors save via temp file + rename)
          scheduleGenerate(filename, 'change-detected');
        } else if (!exists && knownFiles.has(filename)) {
          // File was deleted
          knownFiles.delete(filename);
          scheduleGenerate(filename, 'file-removed');
        }
      } else if (eventType === 'change' && knownFiles.has(filename)) {
        scheduleGenerate(filename, 'change-detected');
      }
    }
  });

  fsWatcher.on('error', (err) => {
    watcher.emit('error', err);
  });

  watcher.setFsWatcher(fsWatcher);

  return watcher;
}
